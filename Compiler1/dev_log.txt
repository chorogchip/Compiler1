
RVO, 우측값 참조를 배우면서 만들었다.
토큰 하나만 까보고 세부 분류로 분기하는 구조의 재귀 하강 파서의 구조로는
var = 3; 의 <assign> 과 var: 의 <label> 을 구분할 수 없다는 것을 꺠달았다.
그래서 <label> 을 ( <id> : ) 에서 ( label <id> : ) 으로 바꿨다.
객체 초기화 시 중괄호와 괄호의 차이점을 알았다.
initializer_list가 있는 객체엔 (), 없는 객체엔 {}를 사용하기로 했다.
또 지역 변수로 객체를 생성할 땐 Obj var = {a, b}, 다른 곳에 넘길 땐 Obj{a, b}로 쓰기로 했다.
이번엔 타입 이름이 const char* const ptr 인데 다음엔 char const *const ptr 로 해야겠다
왜 커멘드가 Declare, Bock, Statement로 나눠지도록 했는지 모르겠다.
적어도 Stament의 분류 중 하나인 Label은 Statement가 아닌 Command에 소속되게 했어야 했다.
그래야 변수 이름을 관리하는 스택에서 쉽게 감지할 수 있다.
다음엔 분류를 잘 해야겠다.
Block만 Command에 속하게 하거나
Declare, Label, Block이 Command에 속하거나. (실행이 안된다?는 공통점)
아 그동안 객체 초기화를 X x = {}; 같은 이상한 방법으로 했었다
이러면 explicit 생성자에서 문제가 발생한다
그래서 모든 초기화를 X x{}; 로 바꿨다
또 바꾸는 김에 위의 const 위치도 전부 바꿨다. *과 &의 위치도 함께.

구문 트리 해석할 떄 문제가 여러가지 생겨서
parse 단계에서 변수 주소의 최댓값을 미리 구하도록 했고
label은 statement가 아닌 command 분류에 넣었다
그리고 goto 뒤에 id가 아닌 expr이 오게 했다.
label로 만든 이름은 그 레이블이 있는 위치(명령어가 몇번째인지)에 해당하는 상수를
나타내도록 바꿨다
즉 label과 다른 값들을 서로 연산할 수 있다.
이를 통해 jump table이나 함수 실행하고 돌아오기 등을 쉽게 구현할 수 있을것이다

에러를 상속시켜서 직접 만들어야 하는데 그냥 있는거 갖다썼다
이성적으로는 당연히 하면 안되는 행동처럼 보인다
이번이 에러 처리를 학습할 좋은 기회인데 말이다

아 명령어 enum만들떄 이름을 막 지어서 서로 안맞는다.
또 target byte code에 단항 마이너스 연산을 안넣었다. 망할..
다음엔 표준을 더 정확하게 정의하는 데 많은 신경을 써야겠다.
그리고 다만들면 exception도 손봐야겠다.
VM말고 트리 해석기 먼저 만들길 잘했다.
정의가 명확히 되어있지 않고 전체적인 설계에 대한 확신이 없을 때는 탑다운 방식이 좋은 것 같다.

if, for, while문 아래에 command가 오게 해뒀는데 여기 declare가 오면 안 된다는 것을 깨달았다.
parser 레벨에서 검출하는 것으로 해결했다. language rule도 수정.
language rule에서 아예 틀을 바꿔야 할 것 같은데 너무 많이 와버렸음.

for문에서 선언 때문에 블럭을 최대 2번 (1번은 선언을 위해, 1번은 command에 block이 올 경우)
만드는 방식을 썼다. 편법 같기도 하다.

오타, 잘못된 Enum 지정, parse나 instruct 명령 빼먹음 등의 버그를 고쳤다.
사실 스택 없이 만들었지만 만들고 보니 메모리의 끝쪽 영역이 스택처럼 쓰이고 있다는 걸 발견했다


// TODO
가상머신(인터프리터) 완성
